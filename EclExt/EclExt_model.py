# -*- coding: utf-8 -*-

"""
/***************************************************************************
 LightPollutionToolbox
                                 A QGIS plugin
 Light pollution indicators (focus on public lighting)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-04-20
        copyright            : (C) 2020 by Mathieu Chailloux
        email                : mathieu@chailloux.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys
import traceback
from io import StringIO
import locale

from PyQt5 import uic, QtWidgets
from PyQt5.QtCore import QVariant, QAbstractTableModel, QModelIndex, Qt, QCoreApplication
from qgis.gui import QgsFileWidget

from ..qgis_lib_mc import qgsUtils

file_dir = os.path.dirname(__file__)
if file_dir not in sys.path:
    sys.path.append(file_dir)
    
FORM_CLASS, _ = uic.loadUiType(os.path.join(
 os.path.dirname(__file__), 'std_eclext.ui'))
    
class FieldRename:
    
    INIT = 'init'
    DEST = 'dest'
    
    def __init__(self, dest,fieldWidget,layerWidget):
        """Constructor."""
        self.dest = dest
        self.fieldWidget = fieldWidget
        self.init = fieldWidget.currentField()
        self.layerWidget = layerWidget
        
    # Connects view and model components for each tab.
    # Connects global elements such as project file and language management.
    def connectComponents(self):
        self.fieldWidget.fieldChanged.connect(self.setField)
        self.layerWidget.layerChanged.connect(self.setLayer)
        
    def setField(self,fieldname):
        self.fieldWidget.setField = fieldname
        self.init = fieldname
        
    def setLayer(self,layer):
        self.fieldWidget.setLayer(layer)
        
    # Initialize Graphic elements for each tab
    def toXML(self,indent=""):
        xmlStr = indent + "<" + self.__class__.__name__
        xmlStr += " " + self.INIT + "=\"" + str(self.init)
        xmlStr += "\" " + self.DEST + "=\"" + str(self.dest)
        xmlStr += "\"/>"
        return xmlStr
        
    def tr(self, message):
        return QCoreApplication.translate('FieldRename', message)
        
        
class MappingModel(QAbstractTableModel):
    
    def __init__(self,feedback=None):
        QAbstractTableModel.__init__(self)
        self.items = []
        self.nbValues = 0
        
    def loadValues(self,values):
        print("values = " + str(values))
        self.values = list(values)
        self.nbValues = len(values)
        self.reclassValues = [None] * self.nbValues
        
    def rowCount(self,parent=QModelIndex()):
        return self.nbValues
    def columnCount(self,parent=QModelIndex()):
        return 2
        
    def data(self,index,role):
        if not index.isValid():
            return QVariant()
        row = index.row()
        col = index.column()
        # print("row = " + str(row))
        # print("col = " + str(col))
        if col == 0:
            val = self.values[row]
        elif col == 1:
            val = self.reclassValues[row]
        else:
            val = None
        # print("val = " + str(val))
        if role not in [Qt.DisplayRole,Qt.EditRole]:
            return QVariant()
        elif row < self.rowCount():
            return QVariant(val)
        else:
            return QVariant()
        
    def setData(self, index, value, role):
        row = index.row()
        col = index.column()
        # print("setData (" + str(index.row()) + ","
            # + str(index.column()) + ") : " + str(value))
        if role == Qt.EditRole:
            if col == 1:
                self.reclassValues[row] = value
            else:
                assert(False)
            self.dataChanged.emit(index, index)
            return True
        return False
            
    def flags(self, index):
        col = index.column()
        if col == 0:
            return Qt.ItemIsSelectable | Qt.ItemIsEnabled
        elif col == 1:
            return Qt.ItemIsSelectable | Qt.ItemIsEnabled | Qt.ItemIsEditable
        else:
            assert(False)
    
        
class FieldMapping(FieldRename):

    def __init__(self,dest,fieldWidget,layerWidget,mappingView):
        super().__init__(dest,fieldWidget,layerWidget)
        self.mappingView = mappingView
        self.model = MappingModel()
        self.mappingView.setModel(self.model)
        
    def setField(self,fieldname):
        super().setField(fieldname)
        layer = self.layerWidget.currentLayer()
        values = qgsUtils.getLayerFieldUniqueValues(layer,fieldname)
        self.model.loadValues(values)
        self.model.layoutChanged.emit()
        

