# -*- coding: utf-8 -*-

"""
/***************************************************************************
 LightPollutionToolbox
                                 A QGIS plugin
 Light pollution indicators (focus on public lighting)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-04-20
        copyright            : (C) 2020 by Mathieu Chailloux
        email                : mathieu@chailloux.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Mathieu Chailloux'
__date__ = '2020-04-20'
__copyright__ = '(C) 2020 by Mathieu Chailloux'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import time, os
from functools import partial

from PyQt5.QtCore import QCoreApplication, QVariant
from qgis.core import (Qgis,
                       QgsProcessing,
                       QgsProcessingAlgRunnerTask,
                       QgsTask,
                       QgsApplication,
                       QgsMessageLog,
                       QgsProcessingContext,
                       QgsProcessingFeedback,
                       #QgsFeatureSink,
                       #QgsFeatureRequest,
                       #QgsFeature,
                       #QgsProject,
                       #QgsVectorLayer,
                       #QgsGraduatedSymbolRenderer,
                       #QgsProcessingUtils,
                       #QgsProcessingContext,
                       #QgsProcessingMultiStepFeedback,
                       #QgsProcessingException,
                       #QgsProcessingAlgorithm,
                       QgsProcessingFeatureSourceDefinition,
                       QgsProcessingParameterDefinition,
                       QgsProcessingParameterBoolean,
                       #QgsProcessingParameterField,
                       QgsProcessingParameterFeatureSource,
                       #QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterEnum,
                       #QgsProcessingParameterExpression,
                       #QgsProcessingParameterMultipleLayers,
                       #QgsProcessingParameterVectorDestination,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterRasterDestination,
                       QgsProcessingParameterFolderDestination,
                       #QgsFields,
                       QgsField)

from ..qgis_lib_mc import utils, qgsUtils, qgsTreatments, feedbacks    


class SourceVisibility(qgsUtils.BaseProcessingAlgorithm):

    ALG_NAME = 'sourceVisibility'
    
    def displayName(self):
        return self.tr('Light sources visibility')
    
    def group(self):
        return self.tr('Direct Pollution')
    
    def groupId(self):
        return 'direct'

    VISI_PROVIDER = 'visibility'
    VIEWSHED_ALGNAME = 'Viewshed'

    DEM = 'DEM'
    OBSERVER_POINTS = 'OBSERVER_POINTS'
    GRID = 'GRID_LAYER'
    
    USE_CURVATURE = 'USE_CURVATURE'
    REFRACTION = 'REFRACTION'
    PRECISION = 'PRECISION'
    ANALYSIS_TYPE = 'ANALYSIS_TYPE'
    OPERATOR = 'OPERATOR'
    OUTPUT_DIR = 'OUTPUT_DIR'
    OUTPUT = 'OUTPUT'

    PRECISIONS = ['Coarse','Normal', 'Fine']   
    TYPES = ['Binary viewshed', 'Depth below horizon','Horizon' ]
    OPERATORS = [ 'Addition', "Minimum", "Maximum"]
    
    def initInputParams(self):
        self.addParameter(QgsProcessingParameterFeatureSource(
            self.OBSERVER_POINTS,
            self.tr('Light sources (observers)'),
            [QgsProcessing.TypeVectorPoint]))
        self.addParameter(QgsProcessingParameterFeatureSource(
            self.GRID,
            self.tr('Grid layer'),
            [QgsProcessing.TypeVectorPolygon],
            optional=True))
        self.addParameter(QgsProcessingParameterRasterLayer(
            self.DEM,
            self.tr('Digital elevation model ')))
    
    def initAdvancedParams(self):
        anaParam = QgsProcessingParameterEnum(
            self.ANALYSIS_TYPE,
            self.tr('Analysis type'),
            self.TYPES, defaultValue=0)
        curvParam = QgsProcessingParameterBoolean(
            self.USE_CURVATURE,
            self.tr('Take in account Earth curvature'),
            False)
        refrParam = QgsProcessingParameterNumber(
            self.REFRACTION,
            self.tr('Atmoshpheric refraction'),
            1, 0.13, False, 0.0, 1.0)
        # Unused for now => why ?
        precParam = QgsProcessingParameterEnum (
           self.PRECISION,
           self.tr('Algorithm precision'),
           self.PRECISIONS,
           defaultValue=1)
        opeParam = QgsProcessingParameterEnum(
            self.OPERATOR,
            self.tr('Combining multiple outputs'),
            self.OPERATORS,
            defaultValue=0)
        # Initialize advanced params with falgs
        advancedParams = [anaParam, curvParam, refrParam, opeParam]
        for param in advancedParams:
            param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.addParameter(param)
            
    def initOutputParams(self):
        self.addParameter(QgsProcessingParameterFolderDestination(
            self.OUTPUT_DIR,
            self.tr("Output directory for temporary files"),
            optional=True))
        self.addParameter(QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output file")))
    
    def initAlgorithm(self, config=None):
        self.initInputParams()
        self.initAdvancedParams()
        self.initOutputParams()
        self.baseDir = None
        
    def mkTmpPath(self,fname):
        if self.baseDir:
            return os.path.join(self.baseDir,fname)
        else:
            return qgsUtils.mkProcTmpPath(fname)

    def processAlgorithm(self, parameters, context, feedback):
    
        qgsUtils.checkPluginInstalled(self.VISI_PROVIDER)
    
        raster = self.parameterAsRasterLayer(parameters,self.DEM, context)
        obs_source, obs_layer = self.parameterAsSourceLayer(parameters,self.OBSERVER_POINTS,context)
        grid_source, grid_layer = self.parameterAsSourceLayer(parameters,self.GRID,context)
        parameters[self.DEM] = raster 

        output_dir = self.parameterAsFileOutput(parameters,self.OUTPUT_DIR,context)
        self.baseDir = output_dir
        output_path = self.parameterAsOutputLayer(parameters,self.OUTPUT,context)
        out_tmp = utils.mkTmpPath(output_path)
        
        if grid_layer:
            curr_grid = self.mkTmpPath('out_grid.gpkg')
            feedback.pushDebugInfo("baseDir = " + str(self.baseDir))
            feedback.pushDebugInfo("curr_grid = " + str(curr_grid))
            curr_grid_layer = qgsUtils.createLayerFromExisting(grid_layer,curr_grid)
            curr_grid_pr = curr_grid_layer.dataProvider()
            curr_grid_pr.addAttributes(grid_layer.fields())
            curr_grid_layer.updateFields()
            nb_feats = grid_layer.featureCount()
            if nb_feats == 0:
                raise QgsProcessingException("Empty grid layer")
            multi_feedback = feedbacks.ProgressMultiStepFeedback(nb_feats * 3, feedback)
            nb_viewsheds = 0
            for count, feat in enumerate(grid_layer.getFeatures(),start=1):
                feat_id = feat.id()
                # Grid feature selection
                grid_layer.selectByIds([feat_id])
                grid_selection = qgsUtils.mkProcTmpPath("grid" + str(feat_id) + ".gpkg")
                qgsTreatments.saveSelectedFeatures(grid_layer,grid_selection,context,multi_feedback)
                # Extracts lamp inside grid
                lamp_selection =  qgsUtils.mkProcTmpPath("source" + str(feat_id) + ".gpkg")
                qgsTreatments.selectByLoc(obs_layer,grid_selection,
                    context=context,feedback=multi_feedback)
                if obs_layer.selectedFeatureCount() == 0:
                    feedback.pushDebugInfo("Skipping empty grid " + str(feat_id))
                    continue
                qgsTreatments.saveSelectedFeatures(obs_layer,lamp_selection,context,multi_feedback)
                multi_feedback.setCurrentStep(count * 3 - 2)
                # lamp_selection = QgsProcessingFeatureSourceDefinition(
                    # obs_layer.id(),selectedFeaturesOnly=True)
                # if obs_layer.selectedFeatureCount() == 0:
                    # feedback.pushDebugInfo("Skipping empty grid " + str(feat_id))
                    # continue
                # out_layer = os.path.join(output_dir,"visibility" + str(feat_id) + ".tif")
                # Call to viewshed alg
                parameters[self.OBSERVER_POINTS] = lamp_selection
                parameters[self.OUTPUT] = out_tmp
                qgsTreatments.applyProcessingAlg(self.VISI_PROVIDER,self.VIEWSHED_ALGNAME,
                    parameters, context,multi_feedback)
                multi_feedback.setCurrentStep(count * 3 - 1)
                nb_viewsheds += 1
                # Copy to output_path
                # qgsTreatments.applyWarpReproject(out_tmp,output_path,
                    # out_type=Qgis.UInt16,nodata_val=0,
                    # context=context,feedback=multi_feedback)
                # Merge to output
                if nb_viewsheds > 1:
                    layers = [output_path, out_tmp]
                    # aggr_func = 10 = sum
                    qgsTreatments.applyRSeries(layers,10,output_path,range=None,
                        context=context,feedback=multi_feedback)
                # Copy to output_path
                elif nb_viewsheds == 1:
                    qgsTreatments.applyWarpReproject(out_tmp,output_path,
                    out_type=Qgis.UInt16,nodata_val=0,
                    context=context,feedback=multi_feedback)
                curr_grid_pr.addFeature(feat)
                multi_feedback.pushDebugInfo("Writing " + str(curr_grid))
                qgsUtils.writeVectorLayer(curr_grid_layer,curr_grid)
                multi_feedback.setCurrentStep(count * 3)
        else:
            parameters[self.OBSERVER_POINTS] = obs_layer
            parameters[self.OUTPUT] = output_path
            qgsTreatments.applyProcessingAlg(self.VISI_PROVIDER,self.VIEWSHED_ALGNAME,
                parameters, context,feedback)
            
        # qgsUtils.removeRaster(out_tmp)
        return { self.OUTPUT : output_path }


        
MESSAGE_CATEGORY = 'My processing tasks'
def testFUnc():
    QgsMessageLog.logMessage('Task finished',
        MESSAGE_CATEGORY,
        Qgis.Warning)
    
def endFunc(context,sucess,results):
    QgsMessageLog.logMessage('Task finished',
        MESSAGE_CATEGORY,
        Qgis.Warning)
    context.append('ttt')
    
class SourceVisibilityPara(SourceVisibility):

    ALG_NAME = 'sourceVisibilityPara'
    
    NB_CURR_TASKS = 0
    
    def displayName(self):
        return self.tr('Light sources visibility (parallelism)')
    
    def groupId(self):
        return 'direct'
        
        
    def task_finished(self,context, feedback, successful, results):
        feedback.pushDebugInfo("END")
        if not successful:
            raise QgsProcessingException('Fail')
        assert(False)
        self.NB_CURR_TASKS -= 1
        
    def print_progress(self,feedback,taskId,progress):
        assert(False)
        feedback.pushDebugInfo("Progress (" + str(taskId) + ") = " + str(progress))
        
        
    def processAlgorithm(self, parameters, context, feedback):
    
        qgsUtils.checkPluginInstalled(self.VISI_PROVIDER)
    
        raster = self.parameterAsRasterLayer(parameters,self.DEM, context)
        obs_source, obs_layer = self.parameterAsSourceLayer(parameters,self.OBSERVER_POINTS,context)
        grid_source, grid_layer = self.parameterAsSourceLayer(parameters,self.GRID,context)
        parameters[self.DEM] = raster 

        output_path = self.parameterAsOutputLayer(parameters,self.OUTPUT,context)
        
        if grid_layer:
            nb_feats = grid_layer.featureCount()
            if nb_feats == 0:
                raise QgsProcessingException("Empty reporting layer")
            multi_feedback = feedbacks.ProgressMultiStepFeedback(nb_feats, feedback)
            out_layers = []
            tasks = []
            task_mgr = QgsApplication.taskManager()
            ttt_list = []
            for count, feat in enumerate(grid_layer.getFeatures()):
                multi_feedback.setCurrentStep(count)
                feat_id = feat.id()
                grid_layer.selectByIds([feat_id])
                grid_selection = qgsUtils.mkProcTmpPath("grid" + str(feat_id) + ".gpkg")
                qgsTreatments.saveSelectedFeatures(grid_layer,grid_selection,context,multi_feedback)
                lamp_selection =  qgsUtils.mkProcTmpPath("source" + str(feat_id) + ".gpkg")
                qgsTreatments.extractByLoc(obs_layer,grid_selection,lamp_selection,
                    context=context,feedback=multi_feedback)
                    
                qgsTreatments.selectByLoc(obs_layer,grid_selection,
                    context=context,feedback=multi_feedback)
                if obs_layer.selectedFeatureCount() == 0:
                    feedback.pushDebugInfo("Skipping empty grid " + str(feat_id))
                    continue
                lamp_selection =  qgsUtils.mkProcTmpPath("source" + str(feat_id) + ".gpkg")
                qgsTreatments.saveSelectedFeatures(obs_layer,lamp_selection,context,multi_feedback)
                # lamp_selection = QgsProcessingFeatureSourceDefinition(
                    # obs_layer.id(),selectedFeaturesOnly=True)
                # if obs_layer.selectedFeatureCount() == 0:
                    # feedback.pushDebugInfo("Skipping empty grid " + str(feat_id))
                    # continue
                out_layer = qgsUtils.mkProcTmpPath("visibility" + str(feat_id) + ".tif")
                parameters[self.OBSERVER_POINTS] = lamp_selection
                parameters[self.OUTPUT] = out_layer
                # qgsTreatments.applyProcessingAlg(self.VISI_PROVIDER,self.VIEWSHED_ALGNAME,
                    # parameters, context,multi_feedback)
                alg_name = self.VISI_PROVIDER + ":" + self.VIEWSHED_ALGNAME
                alg = QgsApplication.processingRegistry().algorithmById(alg_name)
                #context = QgsProcessingContext()
                feedback = QgsProcessingFeedback()
                task = QgsProcessingAlgRunnerTask(alg, parameters, context, multi_feedback)
                #task = QgsTask.fromFunction('test',partial(endFunc,ttt_list))
                #task.executed.connect(endFunc)
                #task.progressChanged.connect(partial(self.print_progress,feedback))
                #task.progressChanged.connect(testFUnc)
                task_mgr.addTask(task)
                task.run()
                #tasks.append(task)
                self.NB_CURR_TASKS += 1
                out_layers.append(out_layer)
            multi_feedback.pushDebugInfo("out_layers = " + str(out_layers))
            multi_feedback.pushDebugInfo("nb_tasks = " + str(self.NB_CURR_TASKS))
            multi_feedback.pushDebugInfo("SLEEP")
            time.sleep(10)
            multi_feedback.pushDebugInfo("ttt_list = " + str(ttt_list))
            
            # for t in tasks:
                # t.wait()
            #time.sleep(600)
            # while task_mgr.count() > 1:
                # multi_feedback.pushDebugInfo("nb_tasks remaining = " + str(task_mgr.count()))
                # time.sleep(10)
            # qgsTreatments.applyRSeries(out_layers,10,output_path,range=None,
                # context=context,feedback=multi_feedback)
        return { self.OUTPUT : output_path }
        