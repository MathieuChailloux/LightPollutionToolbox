# -*- coding: utf-8 -*-

"""
/***************************************************************************
 LightPollutionToolbox
                                 A QGIS plugin
 Light pollution indicators (focus on public lighting)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-04-20
        copyright            : (C) 2020 by Mathieu Chailloux
        email                : mathieu@chailloux.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Mathieu Chailloux'
__date__ = '2020-04-20'
__copyright__ = '(C) 2020 by Mathieu Chailloux'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import time
from functools import partial

from PyQt5.QtCore import QCoreApplication, QVariant
from qgis.core import (QgsProcessing,
                       QgsProcessingAlgRunnerTask,
                       QgsTask,
                       QgsApplication,
                       QgsMessageLog,
                       QgsProcessingContext,
                       QgsProcessingFeedback,
                       #QgsFeatureSink,
                       #QgsFeatureRequest,
                       #QgsFeature,
                       #QgsProject,
                       #QgsVectorLayer,
                       #QgsGraduatedSymbolRenderer,
                       #QgsProcessingUtils,
                       #QgsProcessingContext,
                       #QgsProcessingMultiStepFeedback,
                       #QgsProcessingException,
                       #QgsProcessingAlgorithm,
                       QgsProcessingFeatureSourceDefinition,
                       #QgsProcessingParameterDefinition,
                       QgsProcessingParameterBoolean,
                       #QgsProcessingParameterField,
                       QgsProcessingParameterFeatureSource,
                       #QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterEnum,
                       #QgsProcessingParameterExpression,
                       #QgsProcessingParameterMultipleLayers,
                       #QgsProcessingParameterVectorDestination,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterRasterDestination,
                       #QgsFields,
                       QgsField)

from ..qgis_lib_mc import qgsUtils, qgsTreatments, feedbacks    


class SourceVisibility(qgsUtils.BaseProcessingAlgorithm):

    ALG_NAME = 'sourceVisibility'
    
    def displayName(self):
        return self.tr('Light sources visibility')
    
    def group(self):
        return self.tr('Direct Pollution')
    
    def groupId(self):
        return 'direct'

    VISI_PROVIDER = 'visibility'
    VIEWSHED_ALGNAME = 'Viewshed'

    DEM = 'DEM'
    OBSERVER_POINTS = 'OBSERVER_POINTS'
    GRID = 'GRID_LAYER'
    
    USE_CURVATURE = 'USE_CURVATURE'
    REFRACTION = 'REFRACTION'
    PRECISION = 'PRECISION'
    ANALYSIS_TYPE = 'ANALYSIS_TYPE'
    OPERATOR = 'OPERATOR'
    OUTPUT = 'OUTPUT'

    PRECISIONS = ['Coarse','Normal', 'Fine']   
    TYPES = ['Binary viewshed', 'Depth below horizon','Horizon' ]
    OPERATORS = [ 'Addition', "Minimum", "Maximum"]
    
    def initAlgorithm(self, config=None):

        self.addParameter(QgsProcessingParameterEnum(
            self.ANALYSIS_TYPE,
            self.tr('Analysis type'),
            self.TYPES, defaultValue=0))
        self.addParameter(QgsProcessingParameterFeatureSource(
            self.OBSERVER_POINTS,
            self.tr('Light sources'),
            [QgsProcessing.TypeVectorPoint]))
        self.addParameter(QgsProcessingParameterFeatureSource(
            self.GRID,
            self.tr('Grid layer'),
            [QgsProcessing.TypeVectorPolygon],
            optional=True))
        self.addParameter(QgsProcessingParameterRasterLayer(
            self.DEM,
            self.tr('Digital elevation model ')))
        self.addParameter(QgsProcessingParameterBoolean(
            self.USE_CURVATURE,
            self.tr('Take in account Earth curvature'),
            False))
        self.addParameter(QgsProcessingParameterNumber(
            self.REFRACTION,
            self.tr('Atmoshpheric refraction'),
            1, 0.13, False, 0.0, 1.0))
##        self.addParameter(QgsProcessingParameterEnum (
##            self.PRECISION,
##            self.tr('Algorithm precision'),
##            self.PRECISIONS,
##            defaultValue=1))
        self.addParameter(QgsProcessingParameterEnum (
            self.OPERATOR,
            self.tr('Combining multiple outputs'),
            self.OPERATORS,
            defaultValue=0))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
            self.tr("Output file")))

    def processAlgorithm(self, parameters, context, feedback):
    
        qgsUtils.checkPluginInstalled(self.VISI_PROVIDER)
    
        raster = self.parameterAsRasterLayer(parameters,self.DEM, context)
        obs_source, obs_layer = self.parameterAsSourceLayer(parameters,self.OBSERVER_POINTS,context)
        grid_source, grid_layer = self.parameterAsSourceLayer(parameters,self.GRID,context)
        parameters[self.DEM] = raster 

        output_path = self.parameterAsOutputLayer(parameters,self.OUTPUT,context)
        
        if grid_layer:
            nb_feats = grid_layer.featureCount()
            if nb_feats == 0:
                raise QgsProcessingException("Empty reporting layer")
            multi_feedback = feedbacks.ProgressMultiStepFeedback(nb_feats, feedback)
            out_layers = []
            for count, feat in enumerate(grid_layer.getFeatures()):
                multi_feedback.setCurrentStep(count)
                feat_id = feat.id()
                grid_layer.selectByIds([feat_id])
                grid_selection = qgsUtils.mkProcTmpPath("grid" + str(feat_id) + ".gpkg")
                qgsTreatments.saveSelectedFeatures(grid_layer,grid_selection,context,multi_feedback)
                lamp_selection =  qgsUtils.mkProcTmpPath("source" + str(feat_id) + ".gpkg")
                qgsTreatments.extractByLoc(obs_layer,grid_selection,lamp_selection,
                    context=context,feedback=multi_feedback)
                    
                qgsTreatments.selectByLoc(obs_layer,grid_selection,
                    context=context,feedback=multi_feedback)
                if obs_layer.selectedFeatureCount() == 0:
                    feedback.pushDebugInfo("Skipping empty grid " + str(feat_id))
                    continue
                lamp_selection =  qgsUtils.mkProcTmpPath("source" + str(feat_id) + ".gpkg")
                qgsTreatments.saveSelectedFeatures(obs_layer,lamp_selection,context,multi_feedback)
                # lamp_selection = QgsProcessingFeatureSourceDefinition(
                    # obs_layer.id(),selectedFeaturesOnly=True)
                # if obs_layer.selectedFeatureCount() == 0:
                    # feedback.pushDebugInfo("Skipping empty grid " + str(feat_id))
                    # continue
                out_layer = qgsUtils.mkProcTmpPath("visibility" + str(feat_id) + ".tif")
                parameters[self.OBSERVER_POINTS] = lamp_selection
                parameters[self.OUTPUT] = out_layer
                qgsTreatments.applyProcessingAlg(self.VISI_PROVIDER,self.VIEWSHED_ALGNAME,
                    parameters, context,multi_feedback)
                out_layers.append(out_layer)
            multi_feedback.pushDebugInfo("out_layers = " + str(out_layers))
            # aggr_func = 10 = sum
            qgsTreatments.applyRSeries(out_layers,10,output_path,range=None,
                context=context,feedback=multi_feedback)
        return { self.OUTPUT : output_path }
        
MESSAGE_CATEGORY = 'My processing tasks'
def testFUnc():
    QgsMessageLog.logMessage('Task finished',
        MESSAGE_CATEGORY,
        Qgis.Warning)
    
def endFunc(context,sucess,results):
    QgsMessageLog.logMessage('Task finished',
        MESSAGE_CATEGORY,
        Qgis.Warning)
    context.append('ttt')
    
class SourceVisibilityPara(SourceVisibility):

    ALG_NAME = 'sourceVisibilityPara'
    
    NB_CURR_TASKS = 0
    
    def displayName(self):
        return self.tr('Light sources visibility (parallelism)')
    
    def groupId(self):
        return 'direct'
        
        
    def task_finished(self,context, feedback, successful, results):
        feedback.pushDebugInfo("END")
        if not successful:
            raise QgsProcessingException('Fail')
        assert(False)
        self.NB_CURR_TASKS -= 1
        
    def print_progress(self,feedback,taskId,progress):
        assert(False)
        feedback.pushDebugInfo("Progress (" + str(taskId) + ") = " + str(progress))
        
        
    def processAlgorithm(self, parameters, context, feedback):
    
        qgsUtils.checkPluginInstalled(self.VISI_PROVIDER)
    
        raster = self.parameterAsRasterLayer(parameters,self.DEM, context)
        obs_source, obs_layer = self.parameterAsSourceLayer(parameters,self.OBSERVER_POINTS,context)
        grid_source, grid_layer = self.parameterAsSourceLayer(parameters,self.GRID,context)
        parameters[self.DEM] = raster 

        output_path = self.parameterAsOutputLayer(parameters,self.OUTPUT,context)
        
        if grid_layer:
            nb_feats = grid_layer.featureCount()
            if nb_feats == 0:
                raise QgsProcessingException("Empty reporting layer")
            multi_feedback = feedbacks.ProgressMultiStepFeedback(nb_feats, feedback)
            out_layers = []
            tasks = []
            task_mgr = QgsApplication.taskManager()
            ttt_list = []
            for count, feat in enumerate(grid_layer.getFeatures()):
                multi_feedback.setCurrentStep(count)
                feat_id = feat.id()
                grid_layer.selectByIds([feat_id])
                grid_selection = qgsUtils.mkProcTmpPath("grid" + str(feat_id) + ".gpkg")
                qgsTreatments.saveSelectedFeatures(grid_layer,grid_selection,context,multi_feedback)
                lamp_selection =  qgsUtils.mkProcTmpPath("source" + str(feat_id) + ".gpkg")
                qgsTreatments.extractByLoc(obs_layer,grid_selection,lamp_selection,
                    context=context,feedback=multi_feedback)
                    
                qgsTreatments.selectByLoc(obs_layer,grid_selection,
                    context=context,feedback=multi_feedback)
                if obs_layer.selectedFeatureCount() == 0:
                    feedback.pushDebugInfo("Skipping empty grid " + str(feat_id))
                    continue
                lamp_selection =  qgsUtils.mkProcTmpPath("source" + str(feat_id) + ".gpkg")
                qgsTreatments.saveSelectedFeatures(obs_layer,lamp_selection,context,multi_feedback)
                # lamp_selection = QgsProcessingFeatureSourceDefinition(
                    # obs_layer.id(),selectedFeaturesOnly=True)
                # if obs_layer.selectedFeatureCount() == 0:
                    # feedback.pushDebugInfo("Skipping empty grid " + str(feat_id))
                    # continue
                out_layer = qgsUtils.mkProcTmpPath("visibility" + str(feat_id) + ".tif")
                parameters[self.OBSERVER_POINTS] = lamp_selection
                parameters[self.OUTPUT] = out_layer
                # qgsTreatments.applyProcessingAlg(self.VISI_PROVIDER,self.VIEWSHED_ALGNAME,
                    # parameters, context,multi_feedback)
                alg_name = self.VISI_PROVIDER + ":" + self.VIEWSHED_ALGNAME
                alg = QgsApplication.processingRegistry().algorithmById(alg_name)
                #context = QgsProcessingContext()
                feedback = QgsProcessingFeedback()
                task = QgsProcessingAlgRunnerTask(alg, parameters, context, multi_feedback)
                #task = QgsTask.fromFunction('test',partial(endFunc,ttt_list))
                #task.executed.connect(endFunc)
                #task.progressChanged.connect(partial(self.print_progress,feedback))
                #task.progressChanged.connect(testFUnc)
                task_mgr.addTask(task)
                task.run()
                #tasks.append(task)
                self.NB_CURR_TASKS += 1
                out_layers.append(out_layer)
            multi_feedback.pushDebugInfo("out_layers = " + str(out_layers))
            multi_feedback.pushDebugInfo("nb_tasks = " + str(self.NB_CURR_TASKS))
            multi_feedback.pushDebugInfo("SLEEP")
            time.sleep(10)
            multi_feedback.pushDebugInfo("ttt_list = " + str(ttt_list))
            
            # for t in tasks:
                # t.wait()
            #time.sleep(600)
            # while task_mgr.count() > 1:
                # multi_feedback.pushDebugInfo("nb_tasks remaining = " + str(task_mgr.count()))
                # time.sleep(10)
            # qgsTreatments.applyRSeries(out_layers,10,output_path,range=None,
                # context=context,feedback=multi_feedback)
        return { self.OUTPUT : output_path }
        